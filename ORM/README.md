## 0. Intro
김영한님의 [자바 ORM 표준 JPA 프로그래밍 - 기본편](https://www.inflearn.com/course/ORM-JPA-Basic#) 를 공부해보자

## 1. SQL 중심적인 개발의 문제점
- 현대 애플리케이션 : 객체 지향 언어 + 관계형 DB
- DB는 SQL만 알아들을 수 있으니 SQL이 너무많아..(SQL 중심코드의 문제점)
  - 무한반복, 지루한 코드.. // 자바 객체를 SQL 로 SQL을 자바 객체로..
  - CRUD에 필드 하나 추가한다면..
  - SQL에 의존적인 개발을 피하기 어렵다.
- 패러다임의 불일치
  - RDB : 데이터를 잘 보관하자 != Object : (필드 + 메서드) 캡슐화
  - 상속, 연관관계, 데이터 타입, 데이터 식별 방법 등의 차이
  - 상속 : 자바 컬렉션에서 조회하면 simple한 걸 RDB 조회는 수많은 SQL 매핑..
  - 연관관계 : 객체는 참조를 사용 테이블은 외래 키를 사용
  - 즉, 객체는 단방향, 테이블은 양방향
- 논리적으로 엔티티 신뢰 문제
  - 서비스, DAO, 나눠놓긴하지만.. 신뢰할 수 있을까?
  - 모든 객체를 미리 로딩 해놓는 것도 불가능
  - 진정한 의미의 계층 분할이 어렵다.(물리적으로는 가능해도)
- 결론 : 객체답게 모델링 할수록 매핑 작업만 늘어난다...
  - 자바 컬렉션에 저장 하듯이 DB에 저장할 수는 없을까?
  
 ## 2. JPA의 등장
- 애플리케이션과 JDBC 사이에서 동작
- 객체분석 -> SQL 생성 -> JDBC API 사용 => 패러다임 불일치 해결
- WHY JPA
  - 생산성, 유지보수, 패러다임 불일치 해결
- 패러다임 불일치
  - JPA가 조인해서 가져옴..
  - 동일한 트랜잭션에서 조회한 엔티티는 같음을 보장
- 트랜잭션을 지원하는 쓰기 지연 - INSERT(버퍼링)
- 지연로딩과 즉시로딩
  - 지연로딩의 문제 : 쿼리가 2번날아감(네트워크를 2번 탄다)
  - JPA는 옵션하나로 조인해서 한번에 가져옴 // 즉시로딩
  - 이 두가지를 맘대로 On/Off