오브젝트 2장

## 1. 객체지향 프로그래밍을 향해-40p
- 클래스를 결정한 후에 클래스에 어떤 속성과 메서드가 필요한지 고민한다…. ->객체지향의 본질과는 거리가 멀다.
- 1. 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민하라.
- 2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 한다.
- 3. 공통된 특성과 상태를 가진 객체들을 타입으로 분류하고 이것을 기반으로 클래스를 구현.

## 2. 도메인 -41p
- 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야.
- 클래스를 구현하거나 다른 개발에 의해 개발된 클래스를 사용할 때 가장 중요한 것은 클래스의 경계를 구분 짓는 것.
- 이유 : 경계의 명확성이 객체의 자율성을 보장하기 때문. // 더 중요한 이유는 프로그래머에게 구현의 자유를 제공하기 때문이다.

## 3. 자율적인 객체 -44p
- 첫 번째 : 객체가 상태와 행동을 함께 가지는 복합적인 존재.
- 두 번째 : 객체가 스스로 판단하고 행동하는 자율적인 존재.
- 캡슐화 : 데이터와 기능을 객체 내부로 함께 묶는 것.
- 접근 제어 메커니즘(접근을 통제하는)의 이유는 객체를 자율적인 존재로 만들기 위해서.
- 객체지향의 핵심이 스스로 상태를 관리하고, 판단하고, 행동하는 자율적인 객체들의 공동체를 구성하는 것.(외부의 간섭을 최소화하는것)
- 설계가 필요한 이유? 변경을 관리하기 위해서!!(변경될 가능성이 있는 세부적인 구현 내용을 private)

## 4. TEMPLATE METHOD 패턴
- 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임.
  
## 5. 상속과 다형성 -59p
- 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드를 이해하기 어려워진다.
- 하지만 다르면 다를수록 코드는 더 유연해지고 확장 가능해진다. 
- 의존성의 양면성(무조건 유연한 설계도, 무조건 읽기 쉬운 코드도 정답이 아니다!)
- 객체지향 설계가 어려우면서도 매력적인 이유.
- 상속이 가치있는이유? 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받기 때문(구현상속이 아니라)
- 인터페이스는 객체가 이해할 수 있는 메시지의 목록을 정의한다는 것
- 즉, 자식은 부모가 수신할 수 있는 모든 메시지를 수신할수있기 때문에 외부에서는 자식을 부모와 동일한 타입으로 간주able
- 동일한 메시지를 전송하지만 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스에 따라달라짐 : 다형성

## 6. 추상화의 힘
- 장점 1 : 요구사항의 정책을 높은 수준에서 서술할 수 있다는것.(세부적인 내용을 무시한 채 상위 정책을 쉽고 간단하게  표현)
        //금액 할인 정책과 비율 할인 정책을 사용한다 -> 할인 정책이 존재한다.
- 장점 2 : 추상화를 이용하면 설계가 좀 더 유연해진다는 것. // 기존구조를 수정하지 않고도 새로운 기능을 쉽게 추가
- 상속의 가장큰 문제점 : 캡슐화를 위반한다는 것, 설계를 유연하지 못하게 만든다는 것.