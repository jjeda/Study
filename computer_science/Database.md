## 데이터베이스 개론
[데이터 베이스 개론 - 김연희](https://book.naver.com/bookdb/book_detail.nhn?bid=14427495)  


## 1. 데이터베이스 기본 개념
- DBMS의 장단점, 발전 과정
- 스키마와 인스턴스
- 3단계 데이터베이스 구조, 데이터 독립성
- 데이터 모델링
- 관계형 모델
- SQL
- DB 설계
- 이상현상, 함수 종속, 정규화
- 트랜잭션
- 회복
- 보안, 권한, 역할
- 응용기술
- 빅데이터



## 2. 데이터베이스 관리 시스템


### DBMS 장점
- 데이터 중복을 통제
- 데이터 독립성 확보: 응용프로그램을 대신해서 데이터베이스에 접근 
- 데이터 동시 공유
- 데이터 보안 향상
- 데이터의 무결성 유지: 새로운 데이터가 입력되거나 변경될 때 유효성 검사가 가능
- 표준화: 모든 접근이 DBMS 를 통해 이루어지기 때문, 접근방식, 데이터 형식 등을 표준화하기 쉽다
- 장애 회복
- 개발 비용이 줄어듦

### DBMS 단점
- 비용이 든다 (파일시스템은 OS와 같이 제공됨)
- 백업 및 회복 방법 복잡(러닝커브)
- 모든 관리가 DBMS 로 집중되어있음



## 3. 데이터베이스 시스템
데이터와 DBMS 를 이용해 조직에 필요한 정보를 제공해주는 전체 시스템


### Schema
데이터 구조와 제약조건을 정의


### 3-Level Database Architecture(feat: 아파트)
목적: Data Independency
- external level: 개별 사용자 관점(집주인 관점)
- conceptual level: 조직 전체 관점(관리인 관점)
- internal level: 물리적인 저장 장치 관점(건설 업체 관점)


### External Level
External schema(sub schema): 외부 단계에서 사용자에게 필요한 데이터베이스 정의
- 사용자마다 업무 내용 및 사용 목적이 다름
- 여러개 존재 가능


### Conceptual Level
Conceptual schema: 모든 사용자에게 필요한 데이터를 통합하여 논리적인 구조를 정의
- 데이터의 종류, 관계, 제약조건, 보안 정책, 접근 권한 등이 포함됨
- 데이터베이스 하나당 개념스키마가 단 하나만 존재
- 사용자는 일부분을 사용함: conceptual schema 를 기초로 external schema 가 만들어짐


### Internal Level
Internal schema: 저장 장치에 실제로 저장되는 방법을 정의
- 레코드의 구조, 필드 크기, 인덱스
- conceptual schema 에 대한 물리적인 저장 구조를 표현하므로 하나만 존재


### Data Independency
하위 스키마를 변경하더라도 상위 스키마가 영향을 받지 않는 특성
- 논리적 데이터 독립성: conceptual schema 가 변경되더라도 external schema 가 영향을 받지 않는 것
- 물리적 데이터 독립성: internal schema 가 변경되더라도 conceptual schema 가 영향을 받지 않는 것



## 4. 데이터 모델링
데이터베이스 설계
- 개념적 모델링: 설계도를 그리는 과정
- 개념적 모델: 설계도를 그릴 때 사용하는 방법이나 도구
- 논리적 모델링: 설계도를 토대로 모델하우스를 만드는 과정
- 논리적 모델: 모델하우스를 만들 때 사용하는 방법이나 도구

### 4.1 Entity-Relationship Diagram
현실 세계를 개체-관계 모델을 이용해 개념적으로 모델링
- Entity: 현실 세계에서 저장할 만한 가치가 있는 것
- Relationship: Entity 간의 의미 있는 연관성
- Attribute: Entity, Relationship 의 속성  


### 4.2 논리적 데이터 모델
Schema: 논리적 데이터 모델로 표현된 데이터베이스의 논리적 구조



## 5. 관계 데이터 모델의 개념
- Attribute: column
- Tuple: row
- Domain: attribute 하나가 가질 수 있는 모든 값의 집합: 일반적으로 정확히 정의하기 힘들어서 데이터 타입으로 정의
  - CHAR, INT..
- Degree: attribute 개수(자주 변하지 않는다)
- Cardinality: tuple 개수(자주 변한다)


### 5.1 릴레이션의 특성
- 투플의 유일성: 하나의 릴레이션에는 동일한 투플이 존재할 수 없다
  - 다른 투플과 구별되는 유일한 특성이 있어야 한다(key)
- 투플의 무순서: 하나의 릴레이션에서 투플 사이의 순서는 무의미하다
  - 데이터베이스는 위치가 아닌 내용으로 검색되므로 투플의 순서는 중요하지 않다
- 속성의 무순서: 하나의 릴레이션에서 속성 사이의 순서는 무의미하다
  - 속성의 순서가 바뀌어도 다른 릴레이션이 될 수 없다
- 속성의 원자성: 모든 속성 값은 더는 분해할 수 없는 하나의 값만 가질 수 있다


### 5.2 키의 종류
- super key: 유일성의 특성을 만족하는 속성 or 속성들의 집합 
  - 유일성을 판단하기 위해 불필요한 속성 값까지 확인하는 비효율적인 작업이 필요할 수 있다
- candidate key: 유일성과 최소성을 만족하는 속성 or 속성들의 집합
- primary key: candidate key 중에서 기본적으로 사용할 키
- alternate key: candidate key - primary key
- foreign key: 속성 or 속성 집합이 다른 릴레이션의 primary key(candidate key)


### 5.3 관계 데이터 모델의 제약

- 개체 무결성 제약조건: 기본키를 구성하는 모든 속성은 널 값을 가지면 안된다
- 참조 무결성 제약조건: 외래키는 참조할 수 없는 값을 가질 수 없다
  - 참조하고 있는 속성 값이 유효한지 판단하는 작업이 필요
  - 투플을 삭제하거나 기본키를 변경하는 연산의경우 다른 릴레이션에서 외래키로 참조하고있는지 확인하는 작업 필요 



## 6. 관계 데이터 연산
관계 대수 연산자
- 일반 집합 연산자
- 순수 관계 연산자

일반 집합 연산자
- 합병가능: 두 릴레이션의 차수가 같고(속성 개수가 같다), 서로 대응되는 속성의 도메인이 같아야함(이름은 달라도된다)
  - 합집합, 교집합, 차집합
- 카디션 프로덕트: 차수는 두 차수의 합, 카디널리티는 곱(교환, 결합법칙 O)

순수 관계 연산자
- 셀렉트: 수평적 부분집합, where 문을 통해 연산
- 프로젝트: 수직적 부분집합
- 조인: 조인 속성(두 릴레이션이 공통으로 가지고 있는 속성)
  - natural join
  - theta join: join 속성이 중복으로 나타남
- 디비전: where 연산 후 해당 속성 제거라고 봐도될듯

세미 조인: 필요한 속성(프로젝트)만으로 릴레이션 구성
외부 조인: 상대 릴레이션에 존재하지 않아 제외된 모든 투플을 포함



## 8. 데이터베이스 설계(E-R 모델)
1. 요구 사항 분석
2. 개념적 설계
3. 논리적 설계
4. 물리적 설계
5. 구현


### 요구 사항 분석
- 데이터베이스의 용도 파악
- 명세서


### 개념적 설계
- DBMS에 독립적인 개념적 구조 설계
- 개념적 스키마(E-R 다이어그램)


### 논리적 설계
- DBMS에 적합한 논리적 구조 설계
- 논리적 스키마(릴레이션 스키마)


### 물리적 설계
- DBMS로 구현 가능한 물리적 구조 설계
- 물리적 스키마

## 구현
- SQL 문을 작성한 후 이를 DBMS에서 실행하여 데이터베이스 생성



## 9.정규화
이상 현상: 관련이 없는 속성들을 하나의 릴레이션에 모아두고 있어서 발생  
정규화: 함수 종속성을 이용하여 관련이 있는 속성들로만 구성, 즉 관련없는 함수 종속성은 분리하자


### 9.1 이상 현상의 종류
- Insertion anomaly: 새 데이터를 삽입하기 위해 불필요한 데이터도 함께 삽입해야 함
- Update anomaly: 중복 투플 중 일부만 변경하여 데이터가 불일치
- Deletion anomaly: 투플을 삭제하면 꼭 필요한 데이터까지 함께 삭제되는 데이터 손실


### 9.2 함수종속
- 결정자가 종속자를 결정하는 관계
- 속성 값은 변할 수 있기 때문에 현재 값이 아닌 속성 자체가 가지고 있는 특성과 의미로 판단
- 기본키와 후보키는 다른 모든 속성들을 함수적으로 결정
- 부분 함수 종속: 기본키의 일부에 종속되는 경우
- 완전 함수 종속: 기본키 전체에만 종속되는 경우



### 9.3 정규형
정규형(Normal From): 정규화된 정도
1. 기본 정규형: 제1, 제2, 제3, 보이스/코드
2. 고급 정규형: 제4, 제5


- 1NF: 모든 속성이 원자 값(관계 데이터베이스의 최소조건)
- 2NF: 1NF를 만족하고, 모든 속성이 완전 함수 종속
  - 부분 함수 종속을 제거하라
  - 조인하여 분해 전의 릴레이션으로 다시 복원할 수 있어야 한다
  - 분해했을 때 정보 손실이 발생하지 않아야 함(nonloss decopmosition)
- 3NF: 2NF를 만족하고, 모든 속성이 기본키에 이행적 함수 종속이 되지 않음
  - 이행적 함수 종속: X -> Y, Y -> Z, Z는 X의 transitive FD
- BNCF(Boyce/Codd): 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키
  - 후보키가 하나라면 단 하나의 기본키
  - but 여러 개 가질 수 있음 -> 이때 이상 현상
- 4NF: 다치 종속을 제거
- 5NF: 조인 종속을 제거    


### Flow
1. DB를 잘못 설계하면 이상 현상이 발생한다
2. 발생하는 이유가뭐지? -> 관련이 없는 것들이 다 모여있어서
3. 관련이 있다는 것은 무슨 말일까? -> 함수적 종속성
4. 어떤 종류의 이상 현상이 존재하지? 
5. 해결하는 방법이 뭘까?
6. 각 Normal Form 이 해결하고자 하는 문제는 무엇?(해결하지 못하는 문제는?)





## 10. 회복과 병행 제어

### 10.1 트랜잭션
- 장애가 발생했을 때 복구 작업을 수행
- 다수의 사용자가 동시에 사용할 수 있도록 제어

**ACID**
- Atomicity: All or noting; 회복기능
- Consistency: 트랜잭션의 시작되기전과 종료된 후가 일관된 상태어야 한다(질량보존의 법칙); 병행 제어 기능
- Isolation: commit or rollback 이 될 때까지 다른 트랜잭션에 고립된 상태; 병행 제어 기능
  - READ_UNCOMMITTED
  - READ_COMMITTED
  - REPEATABLE_READ
  - SERIALIZABLE
- Durability: 장애가 발생하더라도 트랜잭션 작업 결과는 없어지지 않고 데이터베이스에 영구적으로 존재; 회복기능

**상태**
- Active: 트랜잭션 수행중
- Partially committed: 모든 연산 실행된 직후, 데이터 베이스에 반영되기 전 상태
- Committed
- Failed
- Aborted: rollback 연산을 실행한 상태 

### 10.2 장애와 회복
- dump: 주기적으로 다른 저장장치에 복사
- log: 변경 연산이 실행될 때마다 이전 값, 이후 값을 별도의 파일에 기록
  - redo: 변경 연산을 재실행
  - undo: 변경 연산을 취소하여 원래 상태 복구
- 로그 회복
  - 즉시 갱신(immediate update): 연산 결과를 데이터 베이스에 즉시반영하면서 로그 파일에 기록(redo, undo)
  - 지연 갱신(deferred update): 로그 파일에만 기록하고 연산이 다 끝나면 DB 반영(undo 가 필요없겠네)
  - 중간에 check point 를 만들어서 해당 check point 부터 회복 연산    


### 10.3 동시성
Concurrency Control: 여러 트랜잭션이 같은 데이터에 접근하여 연산을 실행하더라도 문제가 없어야함

**문제점**
- lost update: 동시에 두 연산이 수행되어 하나의 연산이 무시됨
- inconsistency: 현재의 트랜잭션이 실행되기 전, 후 에 각각 다른 트랜잭션이 데이터를 읽는 경우 
- cascading rollback: 연쇄적으로 rollback 되어야함 but 하나의 트랜잭션이 rollback 되기전에 commit


**트랜잭션 스케줄**
- 트랜잭션들이 번갈아 가면서 수행되고(interleaving), 순서에 따라 결과가 달라진다
- serial schedule: interleaving 이 아닌 하나의 트랜잭션의 모든 연산이 끝난 후 다른 트랜잭션 연산시작
  - 사실상 동시에 사용 하는 것이 아니므로 성능이 좋지않아 사용 x
- nonserial schedule: interleaving 방식으로 속도가 빠르나, 문제점들이 발생
- serializable schedule: 결과는 serial 방법은 interleaving, 어떻게??
  - 직렬 가능성을 계산하는 것은 매우 어려운 일
  - 따라서 직렬 가능성을 보장하는 Concurrency Control 을 사용하자
  
**Concurrency Control**
기본 원리를 지키면 직렬 가능성을 보장할 수 있다
- Locking: DB, relation, tuple, attribute 모두 locking 의 대상이 될 수 있음
  - 범위가 커질수록 병행성은 낮아지지만 제어가 쉬운 trade-off 관계 
  - 공용 lock(shared): (read !write), 다른 트랜잭션도 공용 lock 실행 가능  
  - 전용 lock(exclusive): 해당 트랜잭션만 연산가능
- 2 Phase Locking Protocol: 기본 Locking 만으로는 직렬 가능성을 보장할 수 없음
  - lock, unlock 에 한번 더 protocol 을 추가하자
  - 확장 phase: (lock, ~unlock)
  - 축소 phase: (~lock, unlock)
  - 직렬 가능성은 보장되지만, dead lock 에 걸릴 수 있음  
- propagation
  - REQUIRED : 부모 트랜잭션 내에서 실행하며 부모 트랜잭션이 없을 경우 새로운 트랜잭션을 생성
  - REQUIRES_NEW : 부모 트랜잭션을 무시하고 무조건 새로운 트랜잭션이 생성
  - SUPPORT : 부모 트랜잭션 내에서 실행하며 부모 트랜잭션이 없을 경우 nontransactionally 로 실행
  - MANDATORY : 부모 트랜잭션 내에서 실행되며 부모 트랜잭션이 없을 경우 예외가 발생
  - NOT_SUPPORT : nontransactionally 로 실행하며 부모 트랜잭션 내에서 실행될 경우 일시 정지
  - NEVER : nontransactionally 로 실행되며 부모 트랜잭션이 존재한다면 예외가 발생
  - NESTED : 해당 메서드가 부모 트랜잭션에서 진행될 경우 별개로 커밋되거나 롤백될 수 있음


### Flow
1. 데이터베이스의 일련의 연산 도중 장애가 발생하면 어떻게될까?
2. 트랜잭션의 조건은?(어떤 특성을 만족해야할까?)
3. 트랜잭션은 어떤 상태들이 있나?
4. 장애가 발생하면 어떻게 복구할까?(크게 2가지 방법)
5. 동시에 여러 사용자가 같은 DB를 사용하면 어떤 문제가 발생?
6. 하나의 트랜잭션이 다 끝나고 다른 트랜잭션이 시작되면 되지않을까? 너무 느려
7. 그렇다면 순서대로 하나의 연산씩 번갈아 가면서 하면되지 -> 문제가 발생 해
8. 그러면 어떻게 할까..

+ ACID 를 만족하기위해 어떤 기능이 필요할까?



## 11. 보안과 권한 관리

**View**
- 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위한 가상 테이블
- 뷰는 가상 테이블이기 때문에 물리적으로 구현되어 있지 않다
- 데이터의 논리적 독립성을 제공
- 필요한 데이터만 뷰로 정의해서 처리할 수 있기 때문에 관리가 용이
- 뷰를 통해서만 데이터에 접근하게 하면 뷰에 나타나지 않는 데이터를 보호
- 기본 테이블의 기본키를 포함한 속성 집합으로 뷰를 구성해야 삽입, 삭제, 갱신, 연산이 가능
- 동일 데이터에 대해 동시에 여러사용자의 상이하게 응답
- 단점
  - 독립적인 인덱스를 가질 수 없다
  - 뷰의 정의를 변경할 수 없다
  - 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신, 연산에 제약이 따름
  
**권한 및 역할**
- GRANT
- REVOKE
