## 데이터베이스
참고 도서
- [데이터 베이스 개론 - 김연희](https://book.naver.com/bookdb/book_detail.nhn?bid=14427495)
- [데이터 베이스 첫 걸음 - 미크, 기무라 메이지](https://book.naver.com/bookdb/book_detail.nhn?bid=11154846)
- [누구나 쉽게 SQL - 홍형경 ](https://book.naver.com/bookdb/book_detail.nhn?bid=15041571)  


## 데이터 모델링

데이터 모델링: 현실 세계에 존재하는 데이터를 컴퓨터 세계로 옮기는 변환 과정

**데이터베이스 설계**
- 개념적 모델링: 설계도를 그리는 과정
- 논리적 모델링: 설계도를 토대로 모델하우스를 만드는 과정

**Entity-Relationship Diagram**
현실 세계를 개체-관계 모델을 이용해 개념적으로 모델링
- Entity: 현실 세계에서 저장할 만한 가치가 있는 것
- Relationship: Entity 간의 의미 있는 연관성
- Attribute: Entity, Relationship 의 속성  


**논리적 데이터 모델**
- Schema: 논리적 데이터 모델로 표현된 데이터베이스의 논리적 구조


### Flow
- 현실세계의 데이터를 DB에 어떻게 저장해야할까?
 


## Relational Database
논리적 데이터 모델의 하나
- Domain: attribute 하나가 가질 수 있는 모든 값의 집합: 일반적으로 정확히 정의하기 힘들어서 데이터 타입(CHAR, INT, ...)으로 정의
- Degree: attribute 개수(자주 변하지 않는다)
- Cardinality: tuple 개수(자주 변한다)


**릴레이션의 특성**
- 투플의 유일성: 하나의 릴레이션에는 동일한 투플이 존재할 수 없다
  - 다른 투플과 구별되는 유일한 특성이 있어야 한다(key)
- 투플의 무순서: 하나의 릴레이션에서 투플 사이의 순서는 무의미하다
  - 데이터베이스는 위치가 아닌 내용으로 검색되므로 투플의 순서는 중요하지 않다
- 속성의 무순서: 하나의 릴레이션에서 속성 사이의 순서는 무의미하다
  - 속성의 순서가 바뀌어도 다른 릴레이션이 될 수 없다
- 속성의 원자성: 모든 속성 값은 더는 분해할 수 없는 하나의 값만 가질 수 있다


**키의 종류**
- super key: 유일성(uniqueness)의 특성을 만족하는 속성 or 속성들의 집합 
  - 유일성을 판단하기 위해 불필요한 속성 값까지 확인하는 비효율적인 작업이 필요할 수 있다
- candidate key: 유일성과 최소성을 만족하는 속성 or 속성들의 집합
- primary key: candidate key 중에서 기본적으로 사용할 키
  - null 값을 가질 수 있는 특성이 포함되지 않은 후보키
  - 값이 자주 변경될 수 있는 속성이 포함되지 않은 후보키(null valudation 작업이 계속)
  - 단순한 후보키: 이해하기 쉽고 처리하기도 쉽
- alternate key: candidate key - primary key
- foreign key: 속성 or 속성 집합이 다른 릴레이션의 primary key(candidate key)


**관계 데이터 모델의 제약**

- 개체 무결성 제약조건: 기본키를 구성하는 모든 속성은 널 값을 가지면 안된다
- 참조 무결성 제약조건: 외래키는 참조할 수 없는 값을 가질 수 없다
  - 참조하고 있는 속성 값이 유효한지 판단하는 작업이 필요
  - 투플을 삭제하거나 기본키를 변경하는 연산의경우 다른 릴레이션에서 외래키로 참조하고있는지 확인하는 작업 필요
  - ON DELETE(UPDATE) NO ACTION: 투플을 삭제하지 못함(default)
  - ON DELETE(UPDATE) CASCADE: 관련 투플을 삭제하지 못함
  - ON DELETE(UPDATE) SET NULL: 관련 투플을 NULL로 변
  - ON DELETE(UPDATE) SET DEFAULT: 기본 값으로 변경 


### Flow
1. 관계형 데이터베이스는 무엇인가??
2. 어떤 특징이 있는가? (유일성)
3. 키의 종류(minor)
4. 적절한 기본키를 찾는 기준은?
5. 관계형 데이터베이스의 지켜야할 규칙은?



## 정규화
이상 현상: 관련이 없는 속성들을 하나의 릴레이션에 모아두고 있어서 발생  
정규화: 함수 종속성을 이용하여 관련이 있는 속성들로만 구성, 즉 관련없는 함수 종속성은 분리하자


**이상 현상의 종류**
- Insertion anomaly: 새 데이터를 삽입하기 위해 불필요한 데이터도 함께 삽입해야 함
- Update anomaly: 중복 투플 중 일부만 변경하여 데이터가 불일치
- Deletion anomaly: 투플을 삭제하면 꼭 필요한 데이터까지 함께 삭제되는 데이터 손실


**함수종속**
- 결정자가 종속자를 결정하는 관계
- 속성 값은 변할 수 있기 때문에 현재 값이 아닌 속성 자체가 가지고 있는 특성과 의미로 판단
- 기본키와 후보키는 다른 모든 속성들을 함수적으로 결정
- 부분 함수 종속: 기본키의 일부에 종속되는 경우
- 완전 함수 종속: 기본키 전체에만 종속되는 경우



**정규형**
정규형(Normal From): 정규화된 정도
- 1NF: 모든 속성이 원자 값(관계 데이터베이스의 최소조건)
- 2NF: 1NF를 만족하고, 모든 속성이 완전 함수 종속
  - 부분 함수 종속을 제거하라
  - 조인하여 분해 전의 릴레이션으로 다시 복원할 수 있어야 한다
  - 분해했을 때 정보 손실이 발생하지 않아야 함(nonloss decopmosition)
- 3NF: 2NF를 만족하고, 모든 속성이 기본키에 이행적 함수 종속이 되지 않음
  - 이행적 함수 종속: X -> Y, Y -> Z, Z는 X의 transitive FD
- BNCF(Boyce/Codd): 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키
  - 후보키가 하나라면 단 하나의 기본키
  - but 여러 개 가질 수 있음 -> 이때 이상 현상
- 4NF: 다치 종속을 제거
- 5NF: 조인 종속을 제거    


### Flow
1. DB를 잘못 설계하면 이상 현상이 발생한다
2. 발생하는 이유가뭐지? -> 관련이 없는 것들이 다 모여있어서
3. 관련이 있다는 것은 무슨 말일까? -> 함수적 종속성
4. 어떤 종류의 이상 현상이 존재하지? 
5. 해결하는 방법이 뭘까?
6. 각 Normal Form 이 해결하고자 하는 문제는 무엇?(해결하지 못하는 문제는?)





## 회복과 병행 제어

### 트랜잭션
- 장애가 발생했을 때 복구 작업을 수행
- 다수의 사용자가 동시에 사용할 수 있도록 제어

**ACID**
- Atomicity: All or noting; 회복기능
- Consistency: 트랜잭션의 시작되기전과 종료된 후가 일관된 상태어야 한다(질량보존의 법칙); 병행 제어 기능
- Isolation: commit or rollback 이 될 때까지 다른 트랜잭션에 고립된 상태; 병행 제어 기능
  - READ_UNCOMMITTED
  - READ_COMMITTED
  - REPEATABLE_READ
  - SERIALIZABLE
- Durability: 장애가 발생하더라도 트랜잭션 작업 결과는 없어지지 않고 데이터베이스에 영구적으로 존재; 회복기능

**상태**
- Active: 트랜잭션 수행중
- Partially committed: 모든 연산 실행된 직후, 데이터 베이스에 반영되기 전 상태
- Committed
- Failed
- Aborted: rollback 연산을 실행한 상태 

### 장애와 회복
- dump: 주기적으로 다른 저장장치에 복사
- log: 변경 연산이 실행될 때마다 이전 값, 이후 값을 별도의 파일에 기록
  - redo: 변경 연산을 재실행
  - undo: 변경 연산을 취소하여 원래 상태 복구
- 로그 회복
  - 즉시 갱신(immediate update): 연산 결과를 데이터 베이스에 즉시반영하면서 로그 파일에 기록(redo, undo)
  - 지연 갱신(deferred update): 로그 파일에만 기록하고 연산이 다 끝나면 DB 반영(undo 가 필요없겠네)
  - 중간에 check point 를 만들어서 해당 check point 부터 회복 연산    


### 동시성
Concurrency Control: 여러 트랜잭션이 같은 데이터에 접근하여 연산을 실행하더라도 문제가 없어야함

**문제점**
- lost update: 동시에 두 연산이 수행되어 하나의 연산이 무시됨
- inconsistency: 현재의 트랜잭션이 실행되기 전, 후 에 각각 다른 트랜잭션이 데이터를 읽는 경우 
- cascading rollback: 연쇄적으로 rollback 되어야함 but 하나의 트랜잭션이 rollback 되기전에 commit


**트랜잭션 스케줄**
- 트랜잭션들이 번갈아 가면서 수행되고(interleaving), 순서에 따라 결과가 달라진다
- serial schedule: interleaving 이 아닌 하나의 트랜잭션의 모든 연산이 끝난 후 다른 트랜잭션 연산시작
  - 사실상 동시에 사용 하는 것이 아니므로 성능이 좋지않아 사용 x
- nonserial schedule: interleaving 방식으로 속도가 빠르나, 문제점들이 발생
- serializable schedule: 결과는 serial 방법은 interleaving, 어떻게??
  - 직렬 가능성을 계산하는 것은 매우 어려운 일
  - 따라서 직렬 가능성을 보장하는 Concurrency Control 을 사용하자
  
**Concurrency Control**
기본 원리를 지키면 직렬 가능성을 보장할 수 있다
- Locking: DB, relation, tuple, attribute 모두 locking 의 대상이 될 수 있음
  - 범위가 커질수록 병행성은 낮아지지만 제어가 쉬운 trade-off 관계 
  - 공용 lock(shared): (read !write), 다른 트랜잭션도 공용 lock 실행 가능  
  - 전용 lock(exclusive): 해당 트랜잭션만 연산가능
- 2 Phase Locking Protocol: 기본 Locking 만으로는 직렬 가능성을 보장할 수 없음
  - lock, unlock 에 한번 더 protocol 을 추가하자
  - 확장 phase: (lock, ~unlock)
  - 축소 phase: (~lock, unlock)
  - 직렬 가능성은 보장되지만, dead lock 에 걸릴 수 있음  
- propagation
  - REQUIRED : 부모 트랜잭션 내에서 실행하며 부모 트랜잭션이 없을 경우 새로운 트랜잭션을 생성
  - REQUIRES_NEW : 부모 트랜잭션을 무시하고 무조건 새로운 트랜잭션이 생성
  - SUPPORT : 부모 트랜잭션 내에서 실행하며 부모 트랜잭션이 없을 경우 nontransactionally 로 실행
  - MANDATORY : 부모 트랜잭션 내에서 실행되며 부모 트랜잭션이 없을 경우 예외가 발생
  - NOT_SUPPORT : nontransactionally 로 실행하며 부모 트랜잭션 내에서 실행될 경우 일시 정지
  - NEVER : nontransactionally 로 실행되며 부모 트랜잭션이 존재한다면 예외가 발생
  - NESTED : 해당 메서드가 부모 트랜잭션에서 진행될 경우 별개로 커밋되거나 롤백될 수 있음


### Flow
1. 데이터베이스의 일련의 연산 도중 장애가 발생하면 어떻게될까?
2. 트랜잭션의 조건은?(어떤 특성을 만족해야할까?)
3. 트랜잭션은 어떤 상태들이 있나?
4. 장애가 발생하면 어떻게 복구할까?(크게 2가지 방법)
5. 동시에 여러 사용자가 같은 DB를 사용하면 어떤 문제가 발생?
6. 하나의 트랜잭션이 다 끝나고 다른 트랜잭션이 시작되면 되지않을까? 너무 느려
7. 그렇다면 순서대로 하나의 연산씩 번갈아 가면서 하면되지 -> 문제가 발생 해
8. 그러면 어떻게 할까..

+ ACID 를 만족하기위해 어떤 기능이 필요할까?



## 인덱스

**full scan, range scan**
- 풀스캔: 모든 투플
- 레인지 스캔: 일부 투플
- 인덱스를 생성해서 풀스캔이 아닌 레인지 스캔을 통해 성능을 개선하자 


**장점**
SQL 문을 변경하지 않아도 성능을 개선
테이블의 데이터에 영향을 주지 않는다


**인덱스의 side, adverse effect**
- 인덱스 갱신의 오버헤드로 update 성능 저하
  - 인덱스는 새로운 데이터의 추가, 기존 데이터의 갱신, 제거가 실행되면 자동으로 인덱스도 갱신됨
  - SELECT 성능은 증가할 수 있으나, INSERT, UPDATE 같은 갱신 SQL의 성능은 낮아진다
- 의도한 것과 다른 인덱스가 사용
  - 한 개의 테이블에 복수의 인덱스를 작성한 경우 발생
  - 옵티마이저도 만능은 아니기 때문에 사용할 수 있는 인덱스 후보가 많으면 옵티마이저도 정확하게 동작하지않음


**기준**
- 크기가 큰 테이블에만 만든다(풀 스캔과 큰차이 x)
- 기본키 제약이나, 유일성 제약이 부여된 열에는 불필요(자동 생성)
- 카디널리티가 높은 column 에 인덱스를 걸어야한다(해당 인덱스로 많은부분을 걸러내야되기때문)


**Balanced Tree**
- 단순히 리스트 형태로 데이터를 보관한다면 full scan -> O(n)
- 그렇다면 바이너리 트리형태로 데이터를 보관하면 되지 않을까? log(n)
- 하지만? insult 와 delete 가 반복되다보면 루트노드 기준 데이터가 편향될 수 있어 -> 시간의 편차가 심해짐
- 그래서 스스로 균형을 잡을 수 있는 balanced-tree 를 사용하자
- insult 와 delete 할 때마다 균형을 잡아줌 -> insult, delete 할 때 시간은 조금 더 걸리겠지만 select 의 시간을 줄일 수 있다  
- 그래서 인덱스가 많다고 무조건 좋은게 아님
- hash 는 단순히 어떤 값에 대한 변형된 값이므로 equal 연산으로는 O(1)의 성능을 가지겠지만 inequal 연산은 찾기 힘들다
- 정렬된 배열로 되어있다면? select 할 때는 더 빠를수도 있지만 delete, create 할 때는??
- red-black tree vs b-tree 이건 메모리 접근(물리적 차이)


### flow
1. 테이블 검색은 어떻게 동작할까?
2. 모든 투플을 조사할 필요가 있을까?
4. 무조건 인덱스를 만들면 좋을까?
5. 그렇다면 효율적으로 인덱스를 생성하는 기준은 무엇일까?
6. 인덱스의 원리는 무엇일까?
7. 다른 자료구조가아닌 B-(+)tree 를 사용하는 이유가 뭘까?



## RDB vs NoSQL
**RDB**
- 정형화된 데이터를 저장: 데이터의 형태, 크기를 미리정하고 테이블 단위로 구분
- 트랜잭션을 통한 ACID
- 조인을 포함한 복잡한 조건을 포함하는 데이터 검색이 가능
- 데이터의 중복없이 한번만 저장

**NoSQL**
일관성보다는 가용성과 확장성에 중점을 두고 있는 데이터베이스 시스템
- 유연한 데이터 모델 지원: 스키마 없이 동작하기 때문에 데이터 구조를 미리 정의할 필요가 없다
- 트랜잭션 기능을 제공하지 않는 대신 저렴한 비용으로 분산 처리 및 병렬 처리
- Key-value
- document-based
- column-based
- graph-based

**RDB vs NoSQL**
- 둘은 경쟁자가아닌 목적이 다른 것
- RDB: 트랜잭션을 통해 일관성을 유지하고, 외래키로 테이블 간의 관계를 표현함으로써 조인과 같은 복잡한 질의를 처리해야한다
- NoSQL: 자유롭게 구조를 바꾸며 대량의 비정형 데이터를 빠르게 저장하고 처리해야한다


### flow
- NoSQL이 분산처리에 유리한 이유는? 
- NoSQL이 복제 및 장애대응에 유리한 이유는?
- 그렇다면 NoSQL은 데이터의 일관성을 아예 보장하지 못하나?
- RDB의 수평적확장이 힘든이유는?



## ETC

### DML
- 집계 함수: SELECT, HAVING 절에만 사용가능 
  - COUNT, MAX, MIN, SUM, AVG
  - COUNT 는 null 값을 무시하기 때문에 기본키나 (*)를 사용하자
  - WHERE 절에서는 사용 불가능
- GROUP BY
  - GROUP BY 절에 있는 속성, 집계 함수 외 속성은 SELECT 에 사용할 수 없다(당연함)
  - HAVING: GROUP BY 버전의 WHERE
- INSERT INTO VALUES
- UPDATE SET 
- DELETE FROM
- JOIN: inner, outer, cartesian, self
- 집합: UNION ALL, UNION(중복제거), INTERSECT, MINUS
- ETC: DISTINCT, IN, BETWEEN 


### 보안 및 권한관리
**View**
- 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위한 가상 테이블
- 뷰는 가상 테이블이기 때문에 물리적으로 구현되어 있지 않다
- 데이터의 논리적 독립성을 제공
- 필요한 데이터만 뷰로 정의해서 처리할 수 있기 때문에 관리가 용이
- 뷰를 통해서만 데이터에 접근하게 하면 뷰에 나타나지 않는 데이터를 보호
- 기본 테이블의 기본키를 포함한 속성 집합으로 뷰를 구성해야 삽입, 삭제, 갱신, 연산이 가능
- 동일 데이터에 대해 동시에 여러사용자의 상이하게 응답
- 단점
  - 독립적인 인덱스를 가질 수 없다
  - 뷰의 정의를 변경할 수 없다
  - 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신, 연산에 제약이 따름
  
**권한 및 역할**
- GRANT
- REVOKE


### 분산 데이터베이스
- CAP 정리: 모든 분산 네트워크에는 시간 지연이 있으며, 연결이 끊어질 수 있다는 것을 인정하자(CAP 중 2개만 만족할 수 있음)
  - Consistency: 모든 읽기 작업에서는 가장 최근데 쓰여진 것을 반환
  - Accessibility: 모든 요청에 대한 응답이 따른다. 반드시 최근에 쓰인 내용이 반영되는 것은 아님
  - Partitionability: 시스템을 노드로 구분, 노드 사이에서 데이터가 유실되더라도 시스템은 계속 제 기능을 한다.
  
  
### Hadoop
- 대용량 데이터를 분산 처리할 수 있는 자바 기반의 프레임워크
- HDFS(분산 파일 시스템)에 데이터를 저장하고, MapReduce(분산 처리 시스템)를 이용해 데이터 처리
- 비용이 적게 들고, 처리 속도가 빠르다