## Operation System

한번에 한개씩 처리하게될 경우 CPU 가 놀게됨(예 IO 처리할 동안)
조건: 어떠한 작업도 실행되기 위해 메인 메모리에 있어야함

결론: 여러 개의 작업들이 메인메모리에 있으면됨
이게 다중프로그래밍이고 이를 위해 멀티 프로세싱이 불가피해지는거겠지(병렬처리)



컴퓨터책상(메인메모리)에 컴퓨터(커널)를 올려놓고 사용하자
읽을 책(다른 프로그램)은 책장(다른 저장장치)에 잘 보관하고있다가 필요해지면 책상에 올려서 공부하자

## Interrupt

**폴링 vs 인터럽트** 
polling: CPU가 일정한 시간 간격을 두고 각 자원들의 상태를 주기적으로 확인
  - 폴링의 간격을 적절히 정해야 하는 문제
  - 각 자원들은 직전 폴링 이후 변화된 자신의 상태를 다음번 폴링 때까지는 알릴 수 없음
  - CPU 는 아무 일이 없었는데도 폴링에 일정량의 시간을 들여야 하는 리소스 낭비
interrupt: 각 자원들이 능동적으로 자신의 상태변화를 CPU에 알리는 방식
  - CPU는 따로 시간을 들이지 않아도 된다
  - 자원들은 상황이 발생하면 즉시 알려 처리를 받을 수 있음

**인터럽트 처리 과정**
1. 장치가 인터럽트 신호를 CPU에게 보냄
2. CPU가 명령어를 실행 중이었다면 먼저 해당 명령어를 실행 완료
3. 인터럽트 신호 확인
4. 현재 실행 중이던 프로그램이 인터럽트 처리 후 다시 실행될 때를 위해 현 상태 정보(PSW, PC 레지스터 정보)를 시스템 스택에 저장
5. 인터럽트 처리 루틴의 시작 주소를 PC에 넣어 인터럽트 처리 루틴을 실행
6. 인터럽트의 처리가 끝나면 이전에 저장하였던 레지스터 값들을 다시 재저장한 후 PSW, PC 값들을 원래 자리에 다시 넣어주고, 실행


## Input/Output
각각의 입출력 장치에는 컨트롤러가 있고 여기에는 CPU 와 입출력할 데이터를 저장할 수 있는 버퍼가 존재한다 

- programmed I/O
- interrupt driven I/O
- Direct Memory Access(DMA)
- Isolated I/O
- Memory-mapped I/O


## Process, Thread

**Process control block**
- 프로세스의 모든 정보를 표현하는 테이블 모양의 자료구조
- PCB의 작업은 매우 빈번하게 일어나므로, PCB는 기본적으로 메모리에 저장 


**프로세스의 상태**
![](asset/process_status.png)
- new
- ready
- Running: CPU 를 할당(dispatch)받아 실행중인 상태실행 상태 
- Blocked: 프로세스가 실행되다가 입출력 처리를 요청하거나 바로 확보 될 수 없는 자원을 요청했을 때의 상태
- Exit
- Suspend: 프로세스가 메모리 공간을 뺏기고 디스크로 나감(swapping) 
- Ready Suspend 
- Blocked Suspend


**Thread**
스레드를 만들고, 없애며, 이들 간의 스위칭에 소요되는 시간과 비용이 프로세스 단위보다 빠르고 저렴
- 프로세스 간의 통신은 커널의 개입을 필요로 하지만
- 한 프로세스 내의 스레드 간의 통신은 메모리와 파일을 공유하기 때문에 커널의 개입이 필요 없다
- CPU의 할당 단위가 스레드 이므로, CPU 스위칭을 위한 쓰레드 단위의 자료는 유지되어야 한다
- 여전히 프로세스 단위로 행해지는 보류, 종료 등은 해당 프로세스에 속하는 전체 스레드에 동일한 영향을 미친다


**스레드의 상태와 동기화**
- 실행, 준비, 대기 상태를 가짐
- 대기는 레지스터 값, 프로그램 카운터, 스택 포인터 등을 보관
- 스레드의 종료는 해당 스레드의 레지스터 값들과 스택을 초기화합니다
- 한 프로세스 내의 스레드들이 주소 공간과 자원을 공유한다
  - 는특정 스레드의 변경이 타 스레드에도 영향이 있기때문에 동기화가 필요


**스레드의 종류**
- 사용자 레벨 스레드
  - 스레드 스위칭에 커널의 개입이 필요 없으므로, 모드 스위칭이 필요 없음
  - OS에 독립적으로 스케쥴링을 사용할 수 있으므로, 어떤 운영체제에서도 운영 가능
  - 특정 스레드의 blocked -> 프로세스 내의 스레드 block
  - CPU가 프로세스 단위로 할당 되기 때문에 다중처리의 환경이 주어진다 하더라도 스레드 단위의 다중처리가 되지 못함
- 커널 레벨 스레드
  - 스케줄링은 커널에 의해 스레드 단위로 이루어지므로 유저 레벨 스레드의 단점을 극복
  - 다중 처리의 환경일 경우 한 프로세스 내의 다수 스레드는 각각 처리기를 할당 받아 병렬로 실행이 가능
  - 한 스레드의 대기 시 같은 프로세스에 속한 다른 스레드로 스위칭이 가능
  - 같은 프로세스에 속한 스레드 간의 스위칭에도 커널의 개입이 필요하므로 모드 스위칭이 필요 