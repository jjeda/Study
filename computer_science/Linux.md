## Linux
[실습과 그림으로 배우는 리눅스 구조](https://book.naver.com/bookdb/book_detail.nhn?bid=14524977)

목표
- 하드웨어 특성을 고려하여 개발할 수 있다.
- 시스템 설계 시 기준으로 삼을 지표가 무엇인지 알 수 있다.
- OS, 하드웨어 관련 오류를 대처할 수 있다.

## 1. 컴퓨터 시스템의 개요

- OS가 없다면 디바이스별로 조작하는 코드를 작성해야 한다.
- 커널모드와 사용자모드를 분리하여 사용자가 직접적으로 디바이스 드라이버에 접근하는 것을 막음

커널
- 프로세스 관리(3장), 프로세스 스케줄링(4장), 메모리 관리(5장) 등
- 커널을 사용할 때는 시스템 콜(2장)을 통해 요청 

프로세스 실행에 있어서는 기억장치 계층이 관여(6장)

저장장치에 보관된 데이터에 간단하기 접근하기위해 프일시스템을 통해 접근(7장)

저장장치의 성능 특성, 성능을 끌어내기 위한 커널의 지원 기능 (8장)

## 2. 사용자 모드로 구현되는 기능

시스템 콜
- 프로세스는 프로세스 생성, 하드웨어 컨트롤이 필요할 경우 커널의 도움을 받아야함 이때 시스템 콜을 통해 요청
- 프로세스 생성, 삭제
- 메모리 확보,해제,
- 프로세스 간 통신(IPC)
- 네트워크
- 파일시스템

strace: 시스템 콜을 추적할 수 있음
- mac에서는 dtruss로 대체할 수 있다

시스템 콜은 보통 함수와 다르게 직접 호출이 불가능함
- 만약 이를 추상화하지 않으면 각각의 프로그램에서 어셈블리 언어로 시스템 콜을 호출해야한다
- OS 에서 이런 시스템 콜만 하는 프로그램을 시스템 콜 wrapper 라고 한다.
 
 
 
 
 ## 3. 프로세스 관리(가상 기억장치 x)
 - 같은 프로그램의 처리를 여러 개의 프로세스가 나누자
 - 전혀 다른 프로그램을 생성하자
 
 다음 fork(), exec() 함수는 커널 함수들이고 이를 실행하기위해서는 시스템 콜을 호출해야한다
 
 
 ### 3.1 fork()
 - 같은 프로그램을 여러 개의 프로세스가 처리하자 라는 목적에는 fork() 함수만을 사용
 - 함수가 실행되면 실행한 프로세스(부모)와 함께 새로운 프로세스(자식)가 1개 생성
 
 1. 자식 메모리 영역 작성 후 부모의 메모리 복사
 2. fork() 함수의 리턴값이 다른 것을 이용하여 부모, 자식이 다른 코드를 실행 하도록 분기
   - 부모는 자식 프로세스의 pid, 자식은 0 리턴
   
```
int main()
{
  pit_t ret;
  ret = fork();

  if (ret == -1) {
    err(EXIT_FAILURE, "fork() failed");
  }
  if (ret == 0) {
    child();
  } else {
    parent(ret);
  }

  // shouldn't reach here
  err(EXIT_FAILURE, "should'nt reach here")
}
```

### 3.2 execve() 
- 전혀 다른 프로그램을 생성할 때
- 실행 파일을 읽고 새로운 프로세스의 데이터로 메모리를 덮어쓴다
- 프로세스의 수가 증가하는 것이 아닌 기존의 프로세스를 변경하는 방식

즉 전혀 다른 프로세스를 새로 생성할 때는
1. 부모에서 fork() 호출
2. 자식에서 exec() 호출 



## 4. 프로세스 스케줄러
- 여러 프로세스를 동시에 동작시킨다.
- 하나의 CPU 는 동시에 하나의 프로세스만 처리할 수 있음
- 하나의 CPU 에 여러 개의 프로세스를 실행해야 할 때는 타임 슬라이스

### 4.1 타임 슬라이스
- 동시에 프로세스를 여러 개 실행하더라도 특정 순간에 논리 CPU에 동작되는 프로세스는 1개
- 라운드로빈 방식
- 대략 같은 타임 슬라이스를 가짐
- 프로세스 종료시간까지 경과 시간은 프로세스 수에 비례

### 4.2 컨텍스트 스위치
- 논리 CPU 상에서 동작하는 프로세스가 바뀌는 것
- 프로세스가 어떤 프로그램을 수행하더라도 타임 슬라이스를 모두 소비하면 발생
- 코드상으로 바로 다음 줄의 코드도 컨텍스트 스위치가 발생하여 더 오래걸릴 수 있음

### 4.3 프로세스 상태
- 실행, 실행 대기, 슬립, 좀비
- idle: 프로세스가 생성되거나 슬립 상태에서 깨어날 때까지 아무 의미없는 루프(실제x)
- 실제로는 휴식 상태로 만들어 소비 전력을 낮춰 대기상태로 만듦

### 4.4 nice()
- 특정 프로세스에 우선순위를 부여


## 5. 메모리 관리

### 5.1 가상 메모리가 없는 경우
- 프로세스 생성 (fork() & exec())
- 동적 메모리 할당

동적 메모리 할당
1. 커널에 메모리 확보용 시스템 콜 호출
2. 필요한 사이즈를 빈 메모리 영역으로부터 잘라내 시작 주소값 반환

문제점
- 메모리 단편화(fragmentation)
- 다른 용도의 메모리에 접근 가능
- 여러 프로세스 다루기 힘듦

메모리 단편화
- 각각의 단편된 메모리를 하나처럼 다루기 힘들다
- 몇개의 영역에 나누어져있는지 확인해야 하므로 불편
- 단편화된 영역보다 큰 메모리를 확보해야되는 경우 실패
- ex.,) 100바이트씩 3개로 단편화 되어있는데 200바이트 할당하려고할 때
  
다른 용도의 메모리에 접근
- 실제 메모리의 주소 값을 통해 접근하기 때문에 다른 메모리에도 접근할 가능성이 있음  

동시에 여러 프로세스
- 동일한 프로세스의 경우 원래 가지고 있던 값과 메모리 주소가 달라 동작하지 않는다(실행파일 내용과 다름)
- 여러 종류 프로그램을 실행할 때도 겹치지 않도록 만들어야함


### 5.2 가상 메모리

페이지: 메모리를 나누는 단위(x86_64의 경우 4KB)
페이지 테이블: 가상 주소와 물리주소 매핑

메모리 할당 과정
1. 실행파일을 읽어 코드영역 + 데이터영역 사이즈만큼 물리 메모리에 할당 후 데이터 복사(디맨드 페이징)
2. 페이지 테이블을 만들고 가상 주소 공간을 물리 주소 공간에 매핑
3. 메모리를 추가적으로 요구하면 새로운 메모리를 할당 후 페이지 테이블에 추가


메모리 단편화 문제 해결
- 물리 주소의 메모리는 단편화 되어있지만 페이지 테이블을 통해 가상 메모리공간은 하나의 큰 영역처럼 보이게 할 수 있다.

다른 용도의 메모리에 접근 가능, 여러 프로세스를 다룰 때의 문제 해결
- 가상 주소 공간과 페이지 테이블은 프로세스별로 만들어진다
- 독립된 가상 주소 공간을 갖기 때문에 다른 용도의 메모리에 접근할 수 없다
- 자신이 사용할 메모리가 물리 메모리에 어디에 놓이는지 신경 쓰지 않는다


### 5.3 가상 메모리의 응용

파일 맵
- 파일 영역을 가상 주소 공간에 메모리 매핑
- 나중에 저장 장치내의 파일에 써짐

디맨드 페이징
- 단순히 커널이 메모리에 확보 후 페이지 테이블을 설정하는 것은 낭비되는 영역이 있음
- 페이지에 처음 접근할 때 할당하는 메모리를 할당하는 방식
- 프로세스에는 할당되었지만 물리 메모리에는 할당되지 않은 상태

fork()
- fork() 함수도 가상 메모리 방식을 통해 고속화된다
- 처음에 자식 프로세스를 복사할 때 페이지 테이블만 복사
- 쓰기 권한을 부모, 자식 모두 무효화
- 이후 한쪽에서 쓰기를 시도할 때 메모리가 복사되고 쓰기 권한이 부여됨

스왑
- 저장 장치의 이룹를 메모리 대신 사용하는 방식
- 물리 메모리가 부족한 상태가 될 때 기조넹 사용하던 물리 메모리의 일부를 저장 장치에 저장하여 빈 공간 확보
- 이 메모리의 내용이 저장된 영역이 스왑영역

계층형 페이지 테이블
- 가상 주소 공간 페이지의 전부를 물리 메모리에 대응하기 힘듦
- 계층형으로 테이블을 구성



## 6. 메모리 계층


### 6.1 캐시 메모리

기본적인 동작 흐름
1. 명령어를 바탕으로 메모리에서 레지스터로 데이터를 읽는다.
2. 레지스터에 있는 데이터를 계산한다.
3. 계산 결과를 메모리에 쓴다.

- 이 때 레지스터에서 계산하는 시간보다 계산 결과를 메모리에 쓰는 시간이 극도로 느림
- 2번이 아무리 빨라도 1번과 3번이 병목이 된다.
- 사실 상 메모리에서 직접 읽고 쓰는 레이턴시와 별 차이가 없음
- 중간의 캐시메모리를 두고 메모리에 직접 접근없이 캐시메모리와 데이터를 주고받는다(훨씬 빠름)
- 캐시 메모리는 변경되었으나 실제 물리 메모리에 반영이 안된 데이터들은 더티로 나타내고
- 나중에 더티체킹 후 백그라운드 처리로 메모리에 다시 기록

### 6.2 페이지 캐시

저장 장치에 접근하는 속도를 최소화하기 위한 커널의 기능
- 메모리에 직접 데이터를 복사하는 것이아니라 커널의 메모리 영역에 복사해둠
- 쓰기 과정에서 더티 플래그(더티 페이지)
- write back: 메모리가 부족할 경우 더티 페이지를 해제하면서 저장장치에 싱크를 맞춰줌
- 메모리가 부족한 경우가 아니라면 백그라운드에서 독립적으로 실행

TODO: hyper thread



## 7. 파일시스템

저장 장치에 접근할 때 직접 접근하지 않고 파일시스템을 통해 접근

파일 시스템
- 어느 정도의 데이터가 있는지, 어디가 빈 영역인지 관리
- 의미 있는 하나의 데이터(이름, 위치, 사이즈 등)를 추가하여 파일이라는 단위로 관리
- 사용자는 데이터의 위치, 사이즈 등의 복잡한 정보를 기억할 필요가 없다.

저널링
- 저널 영역에 아토믹한 처리의 목록을 작성(저널로그)
- 저널 영역의 내용을 바탕으로 데이터를 변경
- 저널로그 작성 중 문제가 생긴다 -> 저널로그만 지워짐
- 실제 수행 중 문제가 생긴다 -> 저널로그로 다시 수행

Copy on Write
- 새로운 내용을 업데이트 할 때 기존의 메모리를 덮어쓰는 방식이 아닌 새로운 메모리 영역에 작성 후 변



## 8. 저장 장치


### 8.1 HDD
1. 필요한 정보 HDD에 전달(섹터 번호, 개수, 종류 등)
2. 스윙 암을 이동, 플래터 회전
3. 데이터 읽고 쓰기

- 1,3 과 다르게 2번은 기계적인 처리로 실제 HDD의 레이턴시 대부분이 이 부분
- HDD는 연속된 섹터의 데이터를 플래터의 회전만으로 읽을 수 있음
- 연속되지 않은 경우 기계적인 처리가 더 오래걸림
- 따라서 각 파일의 데이터를 연속된 영역에 배치하는 것이 중


### 8.2 I/O 스케줄러
블록 장치 계층의 I/O 스케줄러 기능은 블록 장치에 접근하려는 요청을 일정 기간 모아둔 뒤 merge, sort 등을 통해 성능 향상
- merge: 여러 개의 연속된 섹터에 대한 I/O를 하나로 모은다
- sort: 여러 개의 불연속적인 섹터에 대한 I/O 요청을 섹터 번호 순서대로 정리


### 8.3 SSD 의 동작 방식
데이터에 접근하는 방식이 기계적이 아닌 전기적 동작만으로 이루어짐
- 랜덤 접근과 시퀀셜 접근의 차이가 적다.
- 쓰기의 대해서 I/O 사이자그 클 경우 스케줄러의 처리가 오히려 더 오래 걸릴 수 있음

정리
- 파일 안에 데이터가 연속되도록 혹은 가까운 영역에 배치
- 연속된 영역에서의 접근은 여러번으로 나누기보다는 한번에 처리
- 파일에는 되도록 큰 사이즈로 시퀀셜 하게 접근
