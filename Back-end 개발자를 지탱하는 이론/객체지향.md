## 객체지향
- 객체지향의 목적 : 응집력을 높이고 결합도는 낮추는 원칙
- 도구들 : 캡슐화 , 상속, 추상화, 다형성
- 방법 : 5대원칙 (SOLID)
- 효과 : 이해하기 쉬운 코드, 리팩터링, 유지보수, 논리적, 유연성, 재사용성
- Best Practice : 디자인패턴
- 그러한 디자인패턴의 집합 : 프레임워크

### 1. SRP - Single Responsibility Principle
어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.
- 너무 많은 역할과 책임 -> 분리
- 하나의 속성은 하나의 의미를 가져야한다 (잘못된 예 : 토지의 경우는 면적을, 건물인 경우 층수를 )
- 이러한 코드는 불필요한 조건문을 동반하기 때문

### 2. OCP - Open-Closed Principle
엔티티는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다.
- 즉, 자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다
- 기능을 변경하거나 확장할 수 있는 코드이면서 기존의 코드는 변경하지 않아야 한다는 말
- 기존의 코드를 바꾸지 않으면서 기능을 확장할 수 있음(외부로부터)

### 3. LSP - Liskov Substitution Principle
서브 타입은 언제나 자신의 기반 타입(Base Type)으로 교체할 수 있어야 한다
- 하위 클래스 is a kind of 상위 클래스 - 하위 분류는 상위 분류의 한 종류다
- 구현 클래스 is able to 인터페이스 - 구현 분류는 인터페이스 할 수 있어야 한다
- 분류가 아닌 (펭귄 is a kind of 동물) 계층,조직 (아빠와 딸)의 상속구조는 원칙에 위배됨
- 딸은 아빠의 역할을 한다?? 논리적으로 맞지 않다
- 즉, 하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야 한다
- TODO : 상속의 효과

### 4. ISP - Interface Segregation Principle
클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다
- 너무 많은 역할과 책임 -> 인터페이스를 통해 제한 // SRP 와 같은 문제를 다른방식으로 해결
- TODO : why ? SRP > ISP

### 5 . DIP - Dependency Inversion Principle
- 고차원 모듈은 저차원 모듈에 의존하면 안된다. 이 두 모듈 모두 추상화된 것에 의존해야 한다
- 추상화된 것은 구체적인 것에 의존하면 안된다. 구체적인 것이 추상화된 것에 의존해야 한다 
- 자주 변경되는 구체 클래스에 의존하지 마라
- 즉, 자신보다 변하기 쉬운 것에 의존하지 마라

### 그리고 SOC - Separation Of COncern
- 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모으고
- 관심이 다른 것은 가능한 한 따로 떨어져 서로 영향을 주지 않도록 분리
- 하나의 속성, 메서드, 클래스, 모듈, 패키지 에는 하나의 관심사만 들어 있어야 한다
- SRP, ISP, OCP 에 자연스럽게 도달 