## Why going asynchronous and reactive?
- [이희승님 DEVIEW Aremria 발표](https://tv.naver.com/v/11267414) 중..

### 동기적인 서비스의 문제점

요청이 들어오면 쓰레드 풀에서 쓰레드를 할당하여 요청을 처리한다.
이를 효율적으로 처리하기위해 샤딩을 통해 DB 부하를 분산시킨다. 

모든 샤드가 정상적으로 동작한다면 동일한 시간이 사용되어야함 (이상적)
특정 샤드에 문제가 생기면 타임아웃이 발생하고, 해당 샤드 요청을 처리하는 시간이 다른 샤드에 비하여 증가한다.

쓰레드 풀도 문제가 발생 샤드를 해결하기위해 쓰레드들을 할당한다.
도미노 효과처 다른 서비스들에도 문제가 생김
실제 장애가 생긴 시스템은 하나인데 다른 모든 서비스들이 장애가 생기고 알람이 발생하여 문제가 커짐..

쓰레드 풀을 늘리면 잠깐은 해소가 되겠지만 결국 같은 문제가 생기고, 낭비되는 자원이 증가하고, 컨텍스트 스위칭 비용이 발생

#### work around
- 샤드별로 쓰레드 풀을 분리
- 콜 스텍에 사이즈를 극단적으로 줄임

시스템이 변경할 때 끊임없이 follow-up 해줘야함..

### Shall we just go asynchronous, please?
- Memort size & event loop의 개수 정도만 튜닝하면됨 + GC
- 쓰레드 개수에 비해 event loop의 수는 매우 적은 숫자

but 비동기적인 서비스도 주고받는 데이터 자체가 커지고 동시요청수가 많아지면 메모리 사용량이 급격하게 증가하게됨
- 버퍼링을 사용해서 작은 단위로 응답을 생성해서 스트리밍 하는 방식으로 처리해야함
- 이렇게 스트리밍으로 해결해도 클라이언트 측에서 받아줄 수 있어야함 아니면 버퍼링이 생김
- 필요한만큼만 조금씩 주고받는 유기적인 상호작용이 필요한데 이걸 reactive 가 해결해 줌(reactive streaming)
 

#### 다른 관점에서 비교
쓰레드 풀을 이용한 동기식 호출 방식은 코드가 간단하고 순차적으로 동작하기 때문에 
개발자가 코드를 직관적이고 빠르게 작성할 수 있다.

하지만 클라이언트 응답이 올 때까지 쓰레드는 기다려야하고(blocking) 응답이 늦으면 요청에 대한 응답을 기다리는 데에
쓰레드를 모두 할당하여 추가요청을 받을 수 없는 문제가 생김
MSA환경에서는 이런 문제가 타임아웃을 일으키면 해당 서비스 뿐만아니라 다른 서비스에도 영향을 끼침

이러한 관점에서 응답이 올 때까지 기다리는 blocking 방식이아니라 이벤트 루프 기반에 non-blocking 방식이 주목받고있다.


## 참고
- [Naver D2 - Spring WebFlux와 Armeria를 이용하여 Microservice에 필요한 Reactive + RPC 동시에 잡기](https://d2.naver.com/helloworld/6080222)